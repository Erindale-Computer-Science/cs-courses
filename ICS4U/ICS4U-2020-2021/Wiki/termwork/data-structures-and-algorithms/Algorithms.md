## Task(s)

This is a multi-step assignment, take your time to ensure you are completing them properly.

### Task 1 (Research - Sorting, [Q4 - Lesson Video](https://youtu.be/tWq4xNHHUWc))
Complete research on simple O(n<sup>2</sup>) sorting algorithms (you'll be using **_either_** insertion **_or_** selection sort for _Task 4_ below). An example of such an algorithm is bubble sort. Bubble sort resources include a [tutorial](https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/tutorial/), a [visualizer (set size = 6, layout = array, click run)](https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/visualize/), and an [alternative visualizer](https://visual-tracer-ag.herokuapp.com/home)

### Task 2 (Research - Searching, [Q4 - Lesson Video](https://youtu.be/j8dXiSmcJTg))
Complete research on linear and binary searching algorithms. You will need to work with binary search for _Task 4_ below.  Some resources for `linear search` include a [tutorial](https://www.hackerearth.com/practice/algorithms/searching/linear-search/tutorial/), and a [visualizer](https://visual-tracer-ag.herokuapp.com/home).  For `binary search`, some resources include a [tutorial](https://www.hackerearth.com/practice/algorithms/searching/binary-search/tutorial/), and a [visualizer)](https://visual-tracer-ag.herokuapp.com/home).

Another visualization simulation for searching can be found [here](https://www.cs.usfca.edu/~galles/visualization/Search.html) for both linear and binary search.

### Task 3 (Research - Computational Complexity)
Calculating computational complexity can become very complicated; however, we are only going to focus on the basics of it here.  Some resources to help understand the basics of computational complexity include a [general paper](https://www.cs.toronto.edu/~guerzhoy/180/handouts/complexity.pdf) on computational complexity, [bubble sort](https://www.cs.toronto.edu/~guerzhoy/180/lectures/W10/lec3/BubbleSortCompl.html), and [selection sort](https://www.cs.toronto.edu/~guerzhoy/180/lectures/W10/lec1/SelectionSortCompl.html).

### Task 4 (Video Demonstration of Learning)
For the below sub-tasks, you are to demonstrate your learning via a video (or a screen capture with audio overlay).  If you are unable to do either of these (due to technical limitations), let me know and we can seek an alternative.

#### Sorting Task(s)
* Create your own `selection sort` **or** `insertion sort` algorithm, and show it in your video.  The sorting algorithm should be able to sort through a very large list/array of objects (at least 100,000 items).
* Display a portion of the array _before sorting_, sort the array (using your selection or insertion sort), then display the same portion of the array _after sorting_.  Showing the first 20 and last 20 items should be sufficient to demonstrate that the array is sorted (for the videoâ€™s purposes anyways). 
* Complete a computational complexity analysis of your own sorting algorithm and then compare it to the built-in `.sort()` function.  Which one runs faster, why, when, etc.  This requires you to show **empirical data** (i.e. think a science lab where you collect your own data, not theoretical data).* 

#### Searching Task(s):
* Create your own `linear search` **and** `binary search` algorithms that search through the data you sorted in the _Sorting Task(s)_ above.  Show the algorithms in your video at some point.
* Complete a computational complexity analysis of `binary search`.  Ensure that you have **empirical data** to back up your computational complexity analysis.  You will also want empirical evidence of how long it takes `linear search` to run, as you'll need it for the next point (linear search has a worst case computational complexity of O(n)).
* Compare `linear search` versus using `.sort()` + `binary search`.  Which would be faster?  Under what circumstances?  What real-life scenario would we want to use `binary search` over linear search if the data isn't sorted?

## Due Dates and Submission Details

Submit your code and video (or links to them) in Google Classroom. 

Please see the [due dates](./Due-Dates-and-Submission-Details) page for more details on when this is due and how to submit your work.

## Learning Goals and Success Criteria

The [Overarching Learning Goal(s)](./images/ICS4U.jpg) for this include _Data Structures and Algorithms_.
The specific Learning Goal(s) for this include:

  * _We are learning to design, write and analyze complex algorithms and subprograms_&#x1F4D9;&#x1F4D9;&#x1F4D9;

| Learning Goal | Success Criteria | Learning and Improvement Comments |
| ------------- | ---------------- | --------------------------------- |
| &#x1F4D9;&#x1F4D9;&#x1F4D9; | I can use one-dimensional arrays of compound data types (i.e. objects, structures, etc.) | |
| &#x1F4D9;&#x1F4D9;&#x1F4D9; | I can create a **sorting** algorithm (selection or insertion) to sort data in an array. | |
| &#x1F4D9;&#x1F4D9;&#x1F4D9; | I can compare the efficiency of **sorting** algorithms, using run times and computational complexity analysis. | |
| &#x1F4D9;&#x1F4D9;&#x1F4D9; | I can create a **binary search** algorithm to find data in an array. | |
| &#x1F4D9;&#x1F4D9;&#x1F4D9; | I can compare the efficiency of **linear** and **binary** **searches**, using run times and computational complexity analysis. | |